---
description: 
globs: **/domain/**/*.dart
alwaysApply: false
---
### 2. The domain layer
- This layer is responsible for the business logic of the app.
- It is where we will handle the data from the API layer and transform it to be used by the presentation layer. That is the responsibility of the repository classes.

```dart
final userRepositoryProvider = Provider<UserRepository>(
  (ref) => UserRepository(
    userApi: ref.read(userApiProvider),
    subscriptionRepository: ref.read(subscriptionRepositoryProvider),
  ),
);

class UserRepository {
  final UserApi _userApi;
  final SubscriptionRepository _subscriptionRepository;


  UserRepository({
    required UserApi userApi,
  }) : _userApi = userApi;

  Future<User?> get(String id) async {
    final UserDto = await _userApi.get(id);
    if (UserDto == null) {
      return null;
    }
    return User.fromEntity(UserDto);
  }
}
```

- We transformed UserDto to a User
- User can contains more than just UserDto informations (We could also have loaded subscription, user role... )

Example of data model

```dart
import 'package:demo_flutter_cursor/core/data/entities/user/user_entity.dart';

import 'package:demo_flutter_cursor/core/data/models/subscription.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:logger/logger.dart';

part 'user.freezed.dart';

@freezed
sealed class User with _$User {
  const factory User.authenticated({
    required Email email,
    Name? name,
    String? id,
    DateTime? creationDate,
    DateTime? lastUpdateDate,
    Avatar? avatar,
    required bool onboarded,
    Subscription? subscription,
  }) = AuthenticatedUserData;

  const factory User.anonymous({
    String? id,
    bool? onboarded,
    Subscription? subscription,
    DateTime? creationDate,
    DateTime? lastUpdateDate,
  }) = AnonymousUserData;

  const factory User.loading() = LoadingUserData;

  const User._();
}
```

- it use @freezed for immutability and union type
- Note that Email isn't a String. We prefer create a type for this for our domain. SO for example we can check that an Email is valid "new Email.from('myemail@test.com')" throws if provided email isn't valid
