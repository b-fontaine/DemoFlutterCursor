---
description: Describe everything related to domain models and how to create / modify them 
globs: 
alwaysApply: false
---
# Domain Model Creation Guidelines

## General Structure

Domain models are the core business objects of the application. Unlike DTOs which are focused on data transfer, domain models encapsulate business logic and represent business concepts.

## Naming Conventions
- Name domain models without any suffix (e.g., `User`, `Device`)
- Store domain model files in the appropriate directory: `lib/core/domain/models/` for core models or `lib/modules/{module_name}/domain/models/` for module-specific models
- Name the file with the model name in snake_case (e.g., `user.dart`, `device.dart`)

## Implementation Guidelines

### 1. Use @freezed Annotation
- Use the `@freezed` annotation from the `freezed_annotation` package for immutability and union types
- Add the appropriate part statement:
  ```dart
  part '{model_name}.freezed.dart';
  ```

### 2. Structure of Domain Model Classes
- Create a sealed class with the `_$ModelName` mixin
- Implement factory constructors for different states or types of the model
- Use a private constructor with `const ModelName._();`
- Use strong typing instead of primitive types when appropriate (e.g., `Email` instead of `String`)
- Include only fields that are necessary for business logic

### 3. DTO Conversion
- Implement a `fromDTO` factory method to convert from DTO to domain model:
  ```dart
  factory ModelName.fromDTO(ModelNameDTO? dto) {
    // Conversion logic here
  }
  ```
- Implement a `toDTO` method to convert from domain model to DTO:
  ```dart
  ModelNameEntity toDTO() {
    // Conversion logic here
  }
  ```

### 4. Business Logic Methods
- Add methods that encapsulate business logic specific to the model
- Use pattern matching with switch expressions for handling different states

## Best Practices
- Keep domain models focused on business concepts
- Use union types to represent different states (e.g., authenticated vs anonymous user)
- Implement error handling in conversion methods
- Use non-nullable types for required fields
- Prefer immutable objects for domain models
- Use descriptive method names that convey intent

## Example

An example can be found here : [example.dart](mdc:.cursor/rules/templates/example.dart)




