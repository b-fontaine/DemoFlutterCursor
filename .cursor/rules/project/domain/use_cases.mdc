---
description: 
globs: 
alwaysApply: false
---
# Use Cases

- Add "use_cases applied" at the beginning of the chat message.

## Principles
- Each Use Case should do one thing and do it well (Single Responsibility Principle)
- Use Cases are called directly by UI providers/presenters
- Use Cases orchestrate the flow of data between UI and data layers
- They contain business logic but delegate data operations to repositories
- It must not manipulate DTO, only domain models

## Structure and Naming
- Create one class per Use Case
- Name the class with a verb describing the action (e.g., `GetUserUseCase`, `SaveSettingsUseCase`)
- Place Use Cases in the `domain` layer of their respective module, in a package `usecases`
- Group related Use Cases in a subdirectory when appropriate

## Implementation
- Always follow TDD : create domain model classes first, then use case with empty implementation, then unit test for the use case, then implementation.
- Run unit tests after each modification of the use case implementation.
- Each Use Case should have a `call()` method, allowing it to be invoked like a function
- Use cases must be called as a function (ex : `final result = _myUseCase();`)
- Inject repositories and other dependencies via constructor
- Make dependencies `final` and private with underscore prefix
- Return domain models, not entities or DTOs
- Handle business logic and validations
- Do not directly access APIs or storage, use repositories instead

## Riverpod Integration
- Each Use Case should have a corresponding Riverpod provider in the same file
- Name the provider with camelCase, following the pattern `{useCaseName}Provider`
- Use Provider<YourUseCase> to expose the Use Case instance
- Inject required dependencies from other providers using ref.read()
- Avoid using ref.watch() in the provider definition unless dependencies need to be reactive

## Integration with UI Providers
- UI Providers should inject Use Cases via ref.watch() or ref.read()
- Use Cases are invoked by provider methods
- Providers transform Use Case results into UI state
- Multiple Use Cases can be combined in a single UI provider
- Avoid putting business logic in UI providers, delegate to Use Cases instead
- For asynchronous operations, use UI providers to manage loading and error states

## Parameters
- Use named parameters when a Use Case requires multiple parameters
- For Use Cases with a single parameter, positional parameters are acceptable
- Include validation of input parameters when necessary

## Error Handling
- Use Cases should handle domain-specific errors
- Consider returning custom Result objects for complex operations that can have multiple failure modes
- Document expected exceptions
- UI Providers should handle and transform domain exceptions into user-friendly error messages

## Testing
- Every Use Case should have unit tests
- Mock or fake the dependencies (repositories) in tests
- Test both success and failure scenarios
- When testing UI providers, mock the Use Cases to focus on testing state management
- For testing Riverpod providers, use ProviderContainer to override dependencies

## Example

An example can be found here : [get_example_usecase.dart](mdc:.cursor/rules/templates/get_example_usecase.dart)